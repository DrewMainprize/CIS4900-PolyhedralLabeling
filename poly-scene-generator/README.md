# polyhedral scene generator

The Polygonal Scene Generator generates a random polygonal scene based on parameters selected by the user, displays and rotates the scene, and outputs the scene to a file in Wavefront .obj format.

## Running the Program

The Polygonal Scene Generator can be run from the command prompt or by double-clicking the icon.  To run from the command prompt enter

	```poly_scene_1_7.exe [number of planes] [probability each polyhedron is visible] [filename]```

All of the parameters are optional, and when run the program will bring up a dialog allowing the user to modify these parameters, with default values for blank or invalid values.

“number of planes” is the integer number of randomly generated planes used to generate the scene (further explained under “Mathematical Details”).  More planes will lead to a more complex scene, while a very low value for this parameter may produce a blank scene.  Reasonable values range from 10 to 30.

“probability each polyhedron is visible” is a probability applied independently to each polyhedron generated by the program; it is the probability that each polyhedron will actually be displayed, instead of being blank.  Allowable values range from 0.0 (which will display nothing) to 1.0.

“filename” is the name of the Wavefront .obj file that the visible polyhedra in the scene will be output to, in the same directory as the executable.  It can be viewed as a text file.  The default filename is based on the computer's current date and time (to the second, to prevent duplicates).

## Using the Program

After selecting “Ok” from the dialog the scene will be generated and displayed.  It can be rotated using the cursor keys.  Press 'Esc' to end the program.

## Motivation

The intuition behind this program was that when attempting to parse an ambiguous scene, people typically move their head or change their position.  This allows them to see the scene from another angle as well as seeing how it changes while they move, and in particular how its components change relative to one another.  It would thus be useful to investigate how well a program could parse a scene if it had multiple angles to compare.  The first step would be to create a program to generate such scenes, which was the purpose of this project.  In order to ensure the validity of the results it was necessary that the scenes generated be random; the method by which this was accomplished is described in the following section.

## Mathematical Underpinnings

The Polygonal Scene Generator starts by generating the requested number of planes in vector format (point and normal vector).  To produce the point it randomly generates x, y, and z coordinates in the interval [-1, 1], and then discards the point and tries again if the resulting point is not within a sphere of radius 1 centered on the origin.  The normal vector is a random vector from the origin to the unit sphere, composed of two angles.  The first, phi, is simply a unit vector in the xy-plane; its angle is randomly chosen from [0, 2π].  The second, theta, represents the elevation in the z-plane.  Its interval is [-π, π], but it can't simply be chosen at random from this interval because a random vector is much more likely to point to the equator than to a pole.  Instead, theta is generated by taking acos of a random number in the interval [-1, 1].

From this start scene generation is straightforward.  A line is created everywhere that two planes intersect within the unit sphere, and a point where three planes intersect.  The line segments delineated by the points are checked to see whether they make up a polygon, and the polygons in turn are checked to see whether they make up a polyhedron.  Finally, each polyhedron is randomly determined to be visible or not based on the user-selected “probability each polyhedron is visible” parameter.

## Understanding the Code

This program includes the following classes:

* Line: Represents a line.
* Plane: Represents a plane.
* Point: Represents a point.
* Polygon: Represents a polygon.
* Polyhedron: Represents a polyhedron.

* PointComparator: Allows points (typically on the same line) to be sorted to allow a systematic search for polygons.
* PolygonEdge: Used to help find the next polygon when creating a polyhedron.
* Quaternion: Used to store and manipulate the quaternion that represents all the rotation of the model (via the cursor keys) so far.

* Conglomerate: Represents a contiguous mass of visible polyhedra, and merges shared edges to prevent extraneous lines from being drawn.
* Main: Takes parameters from the command line (if any) and starts the program in motion.  
* Model: Creates the scene from the user-selected parameters.
* View: Creates a dialog to get the parameters from the user, and displays the scene once Model has completed it.  Implements the Controller from the Model-View-Controller paradigm by being an Observer of Model.


The control flow of the program is a follows.  Main receives the parameters from the command line (if any) and instantiates Model and View.  View's constructor adds View's initialize_frame() function to the EventQueue, since this is proper practice for a function which updates a GUI dialog.  

View.initialize_frame() creates the dialog which allows the user to see and modify the program parameters, and when the user clicks "Ok", View.actionPerformed() validates the input and either displays error messages in the dialog or, if the parameters are valid, closes the dialog window and passes the parameters to Model.create_scene().  

Model.create_scene() creates the planes, lines, and points.  The x points on a line divide it into x-1 line segments, and each line segment can be part of up to four polygons, since the line is the intersection of two planes and in each plane there can be a polygon on either side of the line segment; Model.create_scene() iterates through all of these possibilities, calling Model.create_polygon() on each one to attempt to create a polygon.

Model.create_polygon() is given a specific line segment, side, and plane, and attempts to find additional line segments to create a polygon.  It's able to unambiguously determine the line the next segment (if it exists) must be a part of and the point it must share with the current segment, and then looks in both directions along the new line for a point which could complete the new segment.  Any point found is validated by a projection to ensure that the new segment is in the correct direction.  This continues until the line segments loop around to the original segment, or until a necessary segment is found to not exist and the failed polygon is abandoned.

Model.create_scene() then calls create_polyhedra(), which iterates through both sides of all polygons to find all polyhedra.  An initial polygon is selected and its edges are added to a list ('edges') of polygon edges which have not yet been matched.  Each time a polygon is found that matches one of these edges that edge is removed from the list, and the other edges of the new polygon are individually checked against the list; edges which are already in the list are matches and are also removed from the list, while edges which are not in the list are yet to be matched and are added to the list.  If 'edges' is empty this means that all edges have been matched and a valid polyhedron has been found.  Failure to match a given edge means that the polygons being examined are not part of a valid polyhedron, but the function will still iterate through all the edges in order to mark the relevant polygon faces as having been examined.  The actual updating of the edges list is handled by the auxiliary function update_polygon_edges().

Once all polyhedra have been created Model.create_scene() randomly determines which ones will be visible based on the poly_probability value entered by the user.  However, displaying the scene is not as simply as drawing all the visible polyhedra; if two polyhedra share the same polygon then some of their faces will share an edge and be on the same plane, in which case the two faces are actually one and the edges between them should not be drawn.  To fix this issue the visible polyhedra must be gathered into conglomerates, such that polyhedra which are in the same contiguous mass will be in the same conglomerate, and polyhedra which are not will be in separate conglomerates.

Model.create_scene() selects a polyhedron which is not yet in a conglomerate to be the initial polyhedron, and then calls Conglomerate.explore() on the list of visible polyhedra.  Conglomerate.explore() maintains a list of polygons ('explore_list') which are known to be in this conglomerate, and it checks these polygons against the faces of the visible polyhedra; whenever a match is found, it means that the polyhedron must also be in this conglomerate, and the polygons it's composed of must also be checked for further matches.  Additionally, polygons with matches will need to be merged and are added to merge_list, while polygons which do not have matches will need to be drawn and are added to outline_draw_list and draw_list; two draw lists are needed because the outlines can be concave but OpenGL requires the polygon faces to be convex.

Once a conglomerate has found all its member polyhedra, Model.create_scene() calls Conglomerate.merge() to handle the merging of polygons mentioned in the previous paragragh.  Conglomerate.merge() examines all the edges of each polygon in the merge list to check for polygons that need to be combined, and calls Conglomerate.combine_polygons() on them.  Conglomerate.combine_polygons() creates a new polygon from each of the parents by combining the points unique to each parent in the proper order, as well as the endpoints of the sequence of points shared by the parents, calling Conglomerate.merge_lists() to perform the actual merging.

After the conglomerates have been created the scene is complete.  Model.create_scene() outputs the scene data to a Wavefront .obj file and notifies View that it is finished, passing the conglomerate data as it does so.

View is informed of this through its update() function, which creates the window to display the scene.  View.display() is then automatically called to do the actual drawing; it loads the rotation matrix which represents the current state of the quaternion, and then uses OpenGL drawing functions to draw the polygons and their outlines.  Whenever the user presses a cursor key View.keyPressed() is called; this calls Quaternion.rotate() which updates the rotation represented by the quaternion and returns a rotation matrix representing the total rotation to this point.  View.keyPressed() is also called when the user presses the Esc key, in which case it calls View.exit() to terminate the program.

## License


Copyright (c) 2015 Stephen Voland

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.